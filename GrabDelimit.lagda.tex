We begin with grab/delimit.

\begin{code}[hide]
module GrabDelimit where

open import Data.Empty using ( ⊥; ⊥-elim )
open import Relation.Binary.PropositionalEquality using ( _≡_; refl; cong )
open import Data.Nat using ( ℕ; zero; suc; _<_; _≤?_; z≤n; s≤s )
open import Relation.Nullary using ( ¬_ )
open import Relation.Nullary.Decidable using ( True; toWitness )
\end{code}

\begin{code}[hide]
infixr 8 ↑_
infixr 7 _⇒_!_
infixl 7 _·_
infixl 5 _,_
infix  5 ƛ_ μ_
infixl 6 _[_] _⟨_⟩
infix  4 _∋_
infix  2 _⟶_ _⟶*_
\end{code}

\subsection{Syntax}

\begin{code}
data Ty : Set
data Eff : Set

data Ty where
  `ℕ : Ty
  _⇒_!_ : Ty → Ty → Eff → Ty

data Eff where
  ι : Eff
  _,_ : Eff → Ty → Eff

data Ctx : Set where
  ∙ : Ctx
  _,_ : Ctx → Ty → Ctx

variable
  Γ Δ : Ctx
  α β γ αₕ βₕ : Ty
  ε ε' ε'' : Eff

data _∋_ : Ctx → Ty → Set where
  zero : Γ , α ∋ α
  suc : Γ ∋ α → Γ , β ∋ α

data Tm : Ctx → Eff → Ty → Set where
  var : Γ ∋ α → Tm Γ ε α
  ƛ_ : Tm (Γ , α) ε β → Tm Γ ε' (α ⇒ β ! ε)
  _·_ : Tm Γ ε (α ⇒ β ! ε) → Tm Γ ε α → Tm Γ ε β
  zero : Tm Γ ε `ℕ
  suc : Tm Γ ε `ℕ → Tm Γ ε `ℕ
  case : Tm Γ ε `ℕ → Tm Γ ε α → Tm (Γ , `ℕ) ε α → Tm Γ ε α
  μ_ : Tm (Γ , α ⇒ β ! ε) ε (α ⇒ β ! ε) → Tm Γ ε (α ⇒ β ! ε)
  delimit : Tm Γ (ε , α) α → Tm Γ ε α
  grab : Tm (Γ , α ⇒ β ! ε) ε β → Tm Γ (ε , β) α
\end{code}
\begin{code}[hide]
length : Ctx → ℕ
length ∙ = 0
length (Γ , _) = suc (length Γ)

lookup : ∀ {n} → n < length Γ → Ty
lookup {_ , α} {zero} (s≤s z≤n) = α
lookup {Γ , _} {suc n} (s≤s p) = lookup p

count : ∀ {n} (p : n < length Γ) → Γ ∋ lookup p
count {_ , _} {zero} (s≤s z≤n) = zero
count {Γ , _} {suc n} (s≤s p) = suc (count p)

var# : ∀ n {n∈Γ : True (suc n ≤? length Γ)} → Tm Γ ε (lookup (toWitness n∈Γ))
var# n {n∈Γ} = var (count (toWitness n∈Γ))
\end{code}

\subsection{Renaming and Subsitution}

\begin{code}
Ren : Ctx → Ctx → Set
Ren Γ Δ = ∀ {α} → Γ ∋ α → Δ ∋ α

ext : Ren Γ Δ → Ren (Γ , α) (Δ , α)
ext ρ zero = zero
ext ρ (suc i) = suc (ρ i)

ren : Ren Γ Δ → Tm Γ ε α → Tm Δ ε α
ren ρ (var i) = var (ρ i)
ren ρ (ƛ t) = ƛ ren (ext ρ) t
ren ρ (t · u) = ren ρ t · ren ρ u
ren ρ zero = zero
ren ρ (suc t) = suc (ren ρ t)
ren ρ (case n z s) = case (ren ρ n) (ren ρ z) (ren (ext ρ) s)
ren ρ (μ t) = μ ren (ext ρ) t
ren ρ (delimit t) = delimit (ren ρ t)
ren ρ (grab t) = grab (ren (ext ρ) t)

↑_ : Tm Γ ε α → Tm (Γ , β) ε α
↑_ = ren suc
\end{code}

\begin{code}
Sub : Ctx → Ctx → Set
Sub Γ Δ = ∀ {α} → Γ ∋ α → (∀ {ε} → Tm Δ ε α)

exts : Sub Γ Δ → Sub (Γ , α) (Δ , α)
exts σ zero = var zero
exts σ (suc i) = ↑ (σ i)

sub : Sub Γ Δ → Tm Γ ε α → Tm Δ ε α
sub σ (var i) = σ i
sub σ (ƛ t) = ƛ sub (exts σ) t
sub σ (t · u) = sub σ t · sub σ u
sub σ zero = zero
sub σ (suc t) = suc (sub σ t)
sub σ (case n z s) = case (sub σ n) (sub σ z) (sub (exts σ) s)
sub σ (μ t) = μ sub (exts σ) t
sub σ (delimit t) = delimit (sub σ t)
sub σ (grab t) = grab (sub (exts σ) t)

_[_] : Tm (Γ , α) ε β → (∀ {ε'} → Tm Γ ε' α) → Tm Γ ε β
t [ u ] = sub (λ { zero → u; (suc i) → var i }) t
\end{code}

\begin{code}
data Value : Tm Γ ε α → Set where
  ƛ_ : (t : Tm (Γ , α) ε β) → Value {Γ} {ε'} (ƛ t)
  zero : Value {Γ} {ε} zero
  suc : {t : Tm Γ ε `ℕ} → Value t → Value (suc t)

renV : (ρ : Ren Γ Δ) {t : Tm Γ ε α} → Value t → Value (ren ρ t)
renV ρ (ƛ t) = ƛ ren (ext ρ) t
renV ρ zero = zero
renV ρ (suc v) = suc (renV ρ v)

↑V : {t : Tm Γ ε α} → Value t → Value {Γ = Γ , β} (↑ t)
↑V = renV suc

coe : {t : Tm Γ ε α} → Value t → Tm Γ ε' α
coe (ƛ t) = ƛ t
coe zero = zero
coe (suc v) = suc (coe v)
\end{code}

\begin{code}
data PEC Γ ε αₕ : Ty → Set where
  ⟨⟩ : PEC Γ ε αₕ αₕ
  _·₁_ : PEC Γ ε αₕ (α ⇒ β ! ε) → Tm Γ ε α → PEC Γ ε αₕ β
  _·₂_ : {v : Tm Γ ε (α ⇒ β ! ε)} → Value v → PEC Γ ε αₕ α → PEC Γ ε αₕ β
  suc : PEC Γ ε αₕ `ℕ → PEC Γ ε αₕ `ℕ
  case : PEC Γ ε αₕ `ℕ → Tm Γ ε α → Tm (Γ , `ℕ) ε α → PEC Γ ε αₕ α

_⟨_⟩ : PEC Γ ε αₕ α → Tm Γ ε αₕ → Tm Γ ε α
⟨⟩ ⟨ h ⟩ = h
(c ·₁ t) ⟨ h ⟩ = (c ⟨ h ⟩) · t
(_·₂_ {v = t} _ c) ⟨ h ⟩ = t · (c ⟨ h ⟩)
suc c ⟨ h ⟩ = suc (c ⟨ h ⟩)
case c z s ⟨ h ⟩ = case (c ⟨ h ⟩) z s

renPEC : Ren Γ Δ → PEC Γ ε αₕ α → PEC Δ ε αₕ α
renPEC ρ ⟨⟩ = ⟨⟩
renPEC ρ (c ·₁ t) = renPEC ρ c ·₁ ren ρ t
renPEC ρ (v ·₂ c) = renV ρ v ·₂ renPEC ρ c
renPEC ρ (suc c) = suc (renPEC ρ c)
renPEC ρ (case c z s) = case (renPEC ρ c) (ren ρ z) (ren (ext ρ) s)

↑PEC : PEC Γ ε αₕ α → PEC (Γ , β) ε αₕ α
↑PEC = renPEC suc
\end{code}

\subsection{Reduction rules}

\begin{AgdaAlign}
\begin{code}
data _⟶_ : Tm Γ ε α → Tm Γ ε α → Set where
  app : ∀ {t : Tm (Γ , α) ε β} {u}
    → (v : Value u)
    → (ƛ t) · u ⟶ t [ coe v ]

  case-zero : ∀ {z : Tm Γ ε α} {s}
    → case zero z s ⟶ z

  case-suc : ∀ {z : Tm Γ ε α} {s n}
    → (v : Value n)
    → case (suc n) z s ⟶ s [ coe v ]

  delimit-value : {t : Tm Γ (ε , α) α}
    → (v : Value t)
    → delimit t ⟶ coe v

  delimit-grab : ∀ {t : Tm Γ (ε , α) α} (c : PEC Γ (ε , α) αₕ α) {u}
    → t ≡ c ⟨ grab u ⟩
    → delimit t ⟶ u [ ƛ delimit (↑PEC c ⟨ var# 0 ⟩) ]

  unroll : {t : Tm (Γ , α ⇒ β ! ε) ε (α ⇒ β ! ε)}
    → μ t ⟶ t [ ƛ (↑ (μ t)) · var# 0 ]
\end{code}

Here are the congruence rules.

\begin{code}
  cong-·₁ : ∀ {t t' : Tm Γ ε (α ⇒ β ! ε)} {u}
    → t ⟶ t'
    → t · u ⟶ t' · u

  cong-·₂ : ∀ {v : Tm Γ ε (α ⇒ β ! ε)} {t t'}
    → Value v
    → t ⟶ t'
    → v · t ⟶ v · t'

  cong-delimit : {t t' : Tm Γ (ε , α) α}
    → t ⟶ t'
    → delimit t ⟶ delimit t'

  cong-suc : {t t' : Tm Γ ε `ℕ}
    → t ⟶ t'
    → suc t ⟶ suc t'

  cong-case : ∀ {z : Tm Γ ε α} {s n n'}
    → n ⟶ n'
    → case n z s ⟶ case n' z s
\end{code}
\end{AgdaAlign}

\begin{code}
open import Relation.Binary.Construct.Closure.ReflexiveTransitive using ( Star )
open import Relation.Binary.Construct.Closure.ReflexiveTransitive.Properties
  using ( module StarReasoning )

_⟶*_ : Tm Γ ε α → Tm Γ ε α → Set
_⟶*_ = Star _⟶_

module ⟶*-Reasoning {Γ ε α} where
  open StarReasoning (_⟶_ {Γ} {ε} {α}) public
\end{code}

\begin{code}
-- delimit (suc (grab k. k (k 0)))
ex : Tm ∙ ι `ℕ
ex = delimit (suc (grab (var# 0 · (var# 0 · zero))))

_ : ex ⟶* suc (suc zero)
_ =
  begin
    ex
  ≡⟨⟩
    delimit (suc (grab (var# 0 · (var# 0 · zero))))
  ⟶⟨ delimit-grab (suc ⟨⟩) refl ⟩
    (var# 0 · (var# 0 · zero)) [ ƛ delimit (suc (var# 0)) ]
  ≡⟨⟩
    (ƛ delimit (suc (var# 0))) · ((ƛ delimit (suc (var# 0))) · zero)
  ⟶⟨ cong-·₂ (ƛ delimit (suc (var# 0))) (app zero) ⟩
    (ƛ delimit (suc (var# 0))) · delimit (suc zero)
  ⟶⟨ cong-·₂ (ƛ delimit (suc (var# 0))) (delimit-value (suc zero)) ⟩
    (ƛ delimit (suc (var# 0))) · suc zero
  ⟶⟨ app (suc zero) ⟩
    delimit (suc (suc zero))
  ⟶⟨ delimit-value (suc (suc (zero))) ⟩
    suc (suc zero)
  ∎
  where open ⟶*-Reasoning

plus : Tm ∙ ι (`ℕ ⇒ `ℕ ⇒ `ℕ ! ι ! ι)
plus = μ ƛ ƛ case (var# 1) (var# 0) (suc (var# 3 · var# 0 · var# 1))

_ : plus · suc zero · suc zero ⟶* suc (suc zero)
_ =
  begin
    plus · suc zero · suc zero
  ⟶⟨ cong-·₁ (cong-·₁ unroll) ⟩
    (ƛ ƛ case (var# 1) (var# 0) (suc ((ƛ (↑ ↑ ↑ ↑ plus) · var# 0) · var# 0 · var# 1)))
      · suc zero
      · suc zero
  ⟶⟨ cong-·₁ (app (suc zero)) ⟩
    (ƛ case (suc zero) (var# 0) (suc ((ƛ (↑ ↑ ↑ plus) · var# 0) · var# 0 · var# 1)))
      · suc zero
  ⟶⟨ app (suc zero) ⟩
    case (suc zero) (suc zero) (suc ((ƛ ↑ ↑ plus · var# 0) · var# 0 · suc zero))
  ⟶⟨ case-suc zero ⟩
    suc ((ƛ ↑ plus · var# 0) · zero · suc zero)
  ⟶⟨ cong-suc (cong-·₁ (app zero)) ⟩
    suc (plus · zero · suc zero)
  ⟶⟨ cong-suc (cong-·₁ (cong-·₁ unroll)) ⟩
    suc (
      (ƛ ƛ case (var# 1) (var# 0) (suc ((ƛ (↑ ↑ ↑ ↑ plus) · var# 0) · var# 0 · var# 1)))
      · zero
      · suc zero)
  ⟶⟨ cong-suc (cong-·₁ (app zero)) ⟩
    suc ((ƛ case zero (var# 0) (suc ((ƛ (↑ ↑ ↑ plus) · var# 0) · var# 0 · var# 1))) · suc zero)
  ⟶⟨ cong-suc (app (suc zero)) ⟩
    suc (case zero (suc zero) (suc ((ƛ ↑ ↑ plus · var# 0) · var# 0 · suc zero)))
  ⟶⟨ cong-suc case-zero ⟩
    suc (suc zero)
  ∎
  where open ⟶*-Reasoning
\end{code}

\subsection{Progress}

\begin{code}
data Progress : Tm ∙ ε α → Set where
  done : {t : Tm ∙ ε α} → Value t → Progress t
  step : {t t' : Tm ∙ ε α} → t ⟶ t' → Progress t
  bare-grab : ∀ {t : Tm ∙ (ε , α) β} (c : PEC ∙ (ε , α) γ β) {u}
    → t ≡ c ⟨ grab u ⟩
    → Progress t

progress : (t : Tm ∙ ε α) → Progress t
progress (ƛ t) = done (ƛ t)
progress (t · u) with progress t
... | step t⟶t' = step (cong-·₁ t⟶t')
... | bare-grab c eq = bare-grab (c ·₁ u) (cong (_· u) eq)
... | done (ƛ t') with progress u
...   | step u⟶u' = step (cong-·₂ (ƛ t') u⟶u')
...   | done vu = step (app vu)
...   | bare-grab c eq = bare-grab ((ƛ t') ·₂ c) (cong ((ƛ t') ·_) eq)
progress (delimit t) with progress t
... | done vt = step (delimit-value vt)
... | step t⟶t' = step (cong-delimit t⟶t')
... | bare-grab c eq = step (delimit-grab c eq)
progress (grab t) = bare-grab ⟨⟩ refl
progress zero = done zero
progress (suc t) with progress t
... | done vt = done (suc vt)
... | step t⟶t' = step (cong-suc t⟶t')
... | bare-grab c eq = bare-grab (suc c) (cong suc eq)
progress (case n z s) with progress n
... | done zero = step case-zero
... | done (suc vn) = step (case-suc vn)
... | step n⟶n' = step (cong-case n⟶n')
... | bare-grab c eq = bare-grab (case c z s) (cong (λ m → case m z s) eq)
progress (μ t) = step unroll
\end{code}

\begin{code}[hide]
V¬⟶ : {v v' : Tm Γ ε α} → Value v → ¬ (v ⟶ v')
V¬⟶ (suc v) (cong-suc v⟶v') = V¬⟶ v v⟶v'

V-unique : {t : Tm Γ ε α} (v v' : Value t) → v ≡ v'
V-unique (ƛ t) (ƛ .t) = refl
V-unique zero zero = refl
V-unique (suc v) (suc v') = cong suc (V-unique v v')
\end{code}

\begin{code}[hide]
-- ⟶-deterministic : {t s u : Tm Γ ε α} → t ⟶ s → t ⟶ u → s ≡ u
-- ⟶-deterministic (app {t = t} v) (app v') rewrite V-unique v v' = refl
-- ⟶-deterministic (delimit-value v) (delimit-value v') rewrite V-unique v v' = refl
-- ⟶-deterministic (delimit-grab c eq) (delimit-grab c' eq') = {!   !}
-- ⟶-deterministic rec-zero rec-zero = refl
-- ⟶-deterministic (rec-suc v) (rec-suc v') rewrite V-unique v v' = refl
-- ⟶-deterministic (cong-suc t⟶s) (cong-suc t⟶u) rewrite ⟶-deterministic t⟶s t⟶u = refl
-- ⟶-deterministic (cong-·₁ t⟶s) (cong-·₁ t⟶u) rewrite ⟶-deterministic t⟶s t⟶u = refl
-- ⟶-deterministic (cong-·₂ _ t⟶s) (cong-·₂ _ t⟶u) rewrite ⟶-deterministic t⟶s t⟶u = refl
-- ⟶-deterministic (cong-delimit t⟶s) (cong-delimit t⟶u) = cong delimit (⟶-deterministic t⟶s t⟶u)
-- ⟶-deterministic (cong-rec t⟶s) (cong-rec t⟶u) rewrite ⟶-deterministic t⟶s t⟶u = refl
-- ⟶-deterministic (app v) (cong-·₂ _ t⟶u) = ⊥-elim (V¬⟶ v t⟶u)
-- ⟶-deterministic (cong-·₂ _ t⟶s) (app v) = ⊥-elim (V¬⟶ v t⟶s)
-- ⟶-deterministic (delimit-value v) (cong-delimit t⟶u) = ⊥-elim (V¬⟶ v t⟶u)
-- ⟶-deterministic (cong-delimit t⟶s) (delimit-value v) = ⊥-elim (V¬⟶ v t⟶s)
-- ⟶-deterministic (delimit-value v) (delimit-grab c refl) = {!   !} -- ⊥-elim (V¬⟨grab⟩ v c)
-- ⟶-deterministic (delimit-grab c refl) (delimit-value v) = {!   !} -- ⊥-elim (V¬⟨grab⟩ v c)
-- ⟶-deterministic (delimit-grab c refl) (cong-delimit t⟶u) = {!   !} -- ⊥-elim (⟨grab⟩¬⟶ c t⟶u)
-- ⟶-deterministic (cong-delimit t⟶s) (delimit-grab c refl) = {!   !} -- ⊥-elim (⟨grab⟩¬⟶ c t⟶s)
-- ⟶-deterministic (rec-suc v) (cong-rec t⟶u) = ⊥-elim (V¬⟶ (suc v) t⟶u)
-- ⟶-deterministic (cong-rec t⟶s) (rec-suc v) = ⊥-elim (V¬⟶ (suc v) t⟶s)
-- ⟶-deterministic (cong-·₁ t⟶s) (cong-·₂ v t⟶u) = ⊥-elim (V¬⟶ v t⟶s)
-- ⟶-deterministic (cong-·₂ v t⟶s) (cong-·₁ t⟶u) = ⊥-elim (V¬⟶ v t⟶u)
\end{code}
